<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Flexible Joint PID</title>

    <!-- 3dr party imports -->
    <!-- jQuery -->
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.6.0/jquery.min.js"></script>
    <!-- d3 -->
    <script src="https://d3js.org/d3.v7.min.js"></script>

    <!-- my imports -->
    <script src="sim_experiment.js"></script>
</head>

<body>
    <style>
        .debugging {
            /* display: inherit; */
            display: none;
        }

        /* flexible joint classes */
        .base {
            fill: rgb(143, 143, 143);
            stroke: black;
            stroke-width: 2px;
            rx: 20px;
            ry: 20px;
        }

        .head {
            fill: rgb(75, 75, 75);
            stroke: black;
            stroke-width: 2px;
            rx: 10px;
            ry: 10px;
        }

        .arm {
            fill: black;
            stroke: black;
            stroke-width: 2px;
            rx: 2px;
            ry: 2px;
        }

        .spring {
            stroke: white;
            stroke-width: 2px;
        }

        /* output line class */
        .outLine {
            fill: none;
            stroke: blue;
            stroke-width: 2px;
        }

        .refLine {
            fill: none;
            stroke: green;
            stroke-width: 2px;
            /*dashed line with equal spacing*/
            /* stroke-dasharray: 4;  */
        }

        /* input line class */
        .inpLine {
            fill: none;
            stroke: red;
            stroke-width: 2px;
        }
    </style>

    <div class="controls">
        <label for="simcontrols">Simulation controls:</label>
        <button type="button" onclick="startAll()" name="simcontrols">Start</button>
        <button type="button" onclick="stopAll()">Stop</button>
        <button type="button" onclick="resetAll()">Reset</button>
        <br>
        <label for="simSpeed">Simulation speed:</label><br>
        <small> Slow-Motion </small>
        <input type="range" name="simSpeed" min="1" max="100" value="100" class="slider"
            onchange="setRealTimeFactor(this.value)">
        <small> Real-Time </small>
        <br>
        <label for="Kp">Input Kp:</label>
        <input type="number" name="Kp" id="Kp" value="1" step=".1">
        <br>
        <label for="Ki">Input Ki:</label>
        <input type="number" name="Ki" id="Ki" value="0" step=".1">
        <br>
        <label for="Kd">Input Kd:</label>
        <input type="number" name="Kd" id="Kd" value="0" step=".1">
    </div>
    <div id="mychart" class="chart"></div>
    <a href="index.html">
        <button type="button">Back to overview</button>
    </a>

    <script>
        // set the dimensions and margins of the graph
        const margin = { top: 10, right: 30, bottom: 30, left: 10 },
            width = 800 - margin.left - margin.right,
            height = 500 - margin.top - margin.bottom;


        // append the svg object to the body of the page
        let svg = d3.select("#mychart")
            .append("svg")
            .attr("width", width + margin.left + margin.right)
            .attr("height", height + margin.top + margin.bottom)
            .append("g")
            .attr("transform", `translate(${margin.left},${margin.top})`);

        // show svg object size
        svg.append("rect")
            .attr("x", 0).attr("y", 0)
            .attr("width", width)
            .attr("height", height)
            .style("fill", '#eee')
            .classed("debugging", true);

        // Add X axis
        let Xglobal = d3.scaleLinear().domain([0, 100]).range([0, width]);
        // Add X axis
        let Yglobal = d3.scaleLinear().domain([0, 100]).range([0, height]);

        // show the global axis
        // svg.append("g").call(d3.axisBottom(Xglobal)).classed("debugging", true);
        // svg.append("g").call(d3.axisLeft(Yglobal)).classed("debugging", true);

        // row/colum sizing in percent of full canvas
        // x/y: center points for canvas, w/h: width/height of the row
        let rowCol = [{ x: 0, y: 0, w: 100, h: 50, col: [] }, { x: 0, y: 50, w: 100, h: 50, col: [] }];

        // generate the top row
        let rowTop = svg.append("g").attr("transform", `translate(${Xglobal(rowCol[0].x)},${Yglobal(rowCol[0].y)})`);
        // generate the bottom row
        let rowBot = svg.append("g").attr("transform", `translate(${Xglobal(rowCol[1].x)},${Yglobal(rowCol[1].y)})`);

        // TODO: change the layout, so that the flexible joint experiment is in the center of the first row
        // top row columns
        rowCol[0].col = [{ x: 15, y: rowCol[0].h / 2, w: rowCol[0].w * .4, h: rowCol[0].h },];
        rowCol[0].col.push({ x: rowCol[0].col[0].w, y: rowCol[0].h / 2, w: rowCol[0].w * .6, h: rowCol[0].h * .9 });
        let rowTopC1 = rowTop.append("g").attr("transform", `translate(${Xglobal(rowCol[0].col[0].x)},${Yglobal(rowCol[0].col[0].y)})`);
        let rowTopC2 = rowTop.append("g").attr("transform", `translate(${Xglobal(rowCol[0].col[1].x)},${Yglobal(rowCol[0].col[1].y)})`);

        // bottom row columns
        rowCol[1].col = [{ x: 15, y: rowCol[1].h / 2, w: rowCol[1].w * .4, h: rowCol[1].h },];
        rowCol[1].col.push({ x: rowCol[1].col[0].w, y: rowCol[1].h / 2, w: rowCol[1].w * .6, h: rowCol[1].h * .9 });
        let rowBotC1 = rowBot.append("g").attr("transform", `translate(${Xglobal(rowCol[1].col[0].x)},${Yglobal(rowCol[1].col[0].y)})`);
        let rowBotC2 = rowBot.append("g").attr("transform", `translate(${Xglobal(rowCol[1].col[1].x)},${Yglobal(rowCol[1].col[1].y)})`);

        // show the top row axis
        // rowTopC1.append("g").call(d3.axisBottom(Xglobal)).classed("debugging", true);
        // rowTopC1.append("g").call(d3.axisLeft(Yglobal)).classed("debugging", true);

        /*
        /////////////////// draw the flexible joint experiment ///////////////////
        */
        let flexJoint = {};
        flexJoint['base'] = { width: 75, height: 75, }; // size of the base-plate
        flexJoint['head'] = { width: 70, height: 50, }; // size of the head-plate
        flexJoint['arm'] = { width: 120, height: 5, }; // size of the arm
        flexJoint['ref'] = { length: 130, }; // size of the reference line

        // base plate
        rowTopC1.append("rect")
            .attr("x", -flexJoint.base.width / 2)
            .attr("y", -flexJoint.base.height / 2)
            .attr("width", flexJoint.base.width)
            .attr("height", flexJoint.base.height)
            .classed("base", true);

        // head plate
        rowTopC1.append("rect")
            .attr("x", -flexJoint.head.width / 2)
            .attr("y", -flexJoint.head.height / 2)
            .attr("width", flexJoint.head.width)
            .attr("height", flexJoint.head.height)
            .classed("head", true)
            .attr("transform", `rotate(${-0})`);

        // arm
        rowTopC1.append("rect")
            .attr("x", 0)
            .attr("y", -flexJoint.arm.height / 2)
            .attr("width", flexJoint.arm.width)
            .attr("height", flexJoint.arm.height)
            .classed("arm", true)
            .attr("transform", `rotate(${-0})`);

        // springs
        rowTopC1.append("line")
            .attr("x1", 0).attr("y1", -flexJoint.head.height / 2)
            .attr("x2", flexJoint.arm.width / 4).attr("y2", 0)
            .classed("spring", true);
        rowTopC1.append("line")
            .attr("x1", 0).attr("y1", +flexJoint.head.height / 2)
            .attr("x2", flexJoint.arm.width / 4).attr("y2", 0)
            .classed("spring", true);

        // reference 
        rowTopC1.append("line")
            .attr("x1", 0).attr("y1", 0)
            .attr("x2", flexJoint.ref.length).attr("y2", 0)
            .classed("refLine", true);


        // function to update the flexible joint graphic
        function updateFlexJointAngles(headAngle, armAngle, refAngle) {
            // each angle is relative to the global x-axis (right direction in the graph)
            svg.select('.head').attr("transform", `rotate(${-headAngle})`);
            svg.select('.arm').attr("transform", `rotate(${-armAngle})`);
            rowTopC1.select('.refLine').attr("transform", `rotate(${-refAngle})`);
            // the order of the springs is important! We use the index to decide if it is the upper/lower spring
            svg.selectAll('.spring')
                .attr("x1", (d, i) => { return (i * 2 - 1) * flexJoint.head.height / 2 * Math.sin(deg2rad(headAngle)) })
                .attr("y1", (d, i) => { return (i * 2 - 1) * flexJoint.head.height / 2 * Math.cos(deg2rad(headAngle)) })
                .attr("x2", flexJoint.arm.width / 4 * Math.cos(deg2rad(armAngle)))
                .attr("y2", -flexJoint.arm.width / 4 * Math.sin(deg2rad(armAngle)))
        };

        /*
        /////////////////// draw the output graph ///////////////////
        */
        const plotTime = 20; // in seconds

        let outGraph = rowTopC2;
        outGraph['tmax'] = plotTime; // in seconds
        outGraph['angleStart'] = 1; // in deg

        // Add X axis
        let Xout = d3.scaleLinear().domain([0, outGraph.tmax]).range([0, Xglobal(rowCol[0].col[1].w)]).nice();
        // Add Y axis
        let Yout = d3.scaleLinear().domain([-outGraph.angleStart, outGraph.angleStart]).range([Yglobal(rowCol[0].col[1].h) / 2, -Yglobal(rowCol[0].col[1].h) / 2]);

        // container for the data
        outGraph.append("g").append("path").classed('outLine', true);

        // show the axes
        let outGraphXAxisGroup = outGraph.append("g");
        outGraphXAxisGroup.append("g").classed('axes', true).call(d3.axisBottom(Xout));
        let outGraphYAxisGroup = outGraph.append("g").call(d3.axisLeft(Yout));

        // add titles to the axes
        outGraphXAxisGroup.append("text").attr("text-anchor", "end")
            .attr("x", Xglobal(rowCol[0].col[1].w)).attr("y", 40)
            .text("Time in s");

        outGraph.append("text").attr("text-anchor", "middle")
            .attr("transform", "rotate(-90)")
            .attr("y", -40).attr("x", 0)
            .text("Arm angle in deg")

        // line helper function
        // TODO: draw also the second output?
        let outLine = d3.line()
            .defined(d => !isNaN(d.x[1]))
            .x((d, i, all) => Xout(all[all.length - 1].t - d.t))
            .y(d => Yout((d.armAngle)));
        let refLine = d3.line()
            .defined(d => !isNaN(d.x[1]))
            .x((d, i, all) => Xout(all[all.length - 1].t - d.t))
            .y(d => Yout((d.refAngle)));

        function updateOutGraph(data) {
            // compute visible data
            let vis_data = d3.filter(data, (d, i, a) => d.t >= a.last().t - outGraph.tmax);
            var y = outGraph.selectAll('.outLine')
                .data([vis_data]);
            y.enter()
                .append("path").merge(y)
                .attr("d", outLine)
                .classed('outLine', true);

            var w = outGraph.selectAll('.refLine')
                .data([vis_data]);
            w.enter()
                .append("path").merge(w)
                .attr("d", refLine)
                .classed('refLine', true);


            // update Xaxis
            Xout.domain([0, outGraph.tmax]);
            outGraphXAxisGroup.select(".axes").call(d3.axisBottom(Xout));
            // update Xaxis location
            outGraphXAxisGroup.attr("transform", `translate(0,${Yout(0)})`)

            // update Yaxis
            Yout.domain(
                [d3.min(vis_data, (d) => Math.min(d.armAngle, d.refAngle)) - outGraph.angleStart, d3.max(vis_data, (d) => Math.max(d.armAngle, d.refAngle)) + outGraph.angleStart]
            ).nice().clamp(true);
            outGraphYAxisGroup.call(d3.axisLeft(Yout));
        };

        /*
        /////////////////// draw the controls ///////////////////
        */
        let controlsGraph = rowBotC1;
        controlsGraph.attr("id", "graphControls");
        // TODO: actually draw the controls

        /*
        /////////////////// draw the input graph ///////////////////
        */
        let inputGraph = rowBotC2;
        inputGraph['tmax'] = plotTime; // in seconds
        inputGraph['initlMax'] = 1; // initial axis size

        // Add X axis
        let Xinp = d3.scaleLinear().domain([0, inputGraph.tmax]).range([0, Xglobal(rowCol[1].col[1].w)]).nice();
        // Add Y axis
        let Yinp = d3.scaleLinear().domain([-inputGraph.initlMax, inputGraph.initlMax]).range([Yglobal(rowCol[1].col[1].h) / 2, -Yglobal(rowCol[1].col[1].h) / 2]);

        // container for the data
        inputGraph.append("g").append("path").classed('inpLine', true);

        // show the axes
        let inputGraphXAxisGroup = inputGraph.append("g").call(d3.axisBottom(Xinp));
        // TODO: change the X axis so that it behaves like the X axis of the output graph (moves around)
        let inputGraphYAxisGroup = inputGraph.append("g").call(d3.axisLeft(Yinp));

        // add titles to the axes
        inputGraph.append("text").attr("text-anchor", "end")
            .attr("x", Xglobal(rowCol[0].col[1].w)).attr("y", 40)
            .text("Time in s");

        inputGraph.append("text").attr("text-anchor", "middle")
            .attr("transform", "rotate(-90)")
            .attr("y", -40).attr("x", 0)
            .text("Input voltage in V")

        // line helper function
        // data format: [{t:simTime,x:states,u:inputs},{...}]
        let inpLine = d3.line()
            .defined(d => !isNaN(d.x[0]))
            .x((d, i, all) => Xinp(all[all.length - 1].t - d.t))
            .y(d => Yinp(d.u[0]));

        function updateinputGraph(data) {
            // compute visible data
            let vis_data = d3.filter(data, (d, i, a) => d.t >= a.last().t - inputGraph.tmax);
            // update line
            var u = inputGraph.selectAll('.inpLine')
                .data([vis_data]);

            u.enter()
                .append("path").merge(u)
                .attr("d", inpLine)
                .classed('inpLine', true);

            // update Xaxis
            Xinp.domain([0, inputGraph.tmax]);
            inputGraphXAxisGroup.call(d3.axisBottom(Xinp));
            // update Yaxis
            Yinp.domain([-d3.max(vis_data, (e) => Math.abs(e.u)), d3.max(vis_data, (e) => Math.abs(e.u))]);
            inputGraphYAxisGroup.call(d3.axisLeft(Yinp));
        };

        /*
        /////////////////// controls functions ///////////////////
        */
        function startAll() {
            simpleSim.start();
        };
        function stopAll() {
            simpleSim.stop();
        };
        function resetAll() {
            data = [];
            simpleSim.reset();
            simpleSim.plotUpdate;
        };
        function setRealTimeFactor(input) {
            let minFactor = 0.1,
                maxFactor = 1;

            let scale = d3.scaleLinear().domain([1, 100]).range([minFactor, maxFactor]);
            let factor = scale(input);
            simpleSim.simMulti = factor
            outGraph.tmax = plotTime * factor;
            inputGraph.tmax = plotTime * factor;
        };


        /*
        /////////////////// utility functions ///////////////////
        */
        function deg2rad(deg) { return deg / 360 * Math.PI * 2 };
        function rad2deg(rad) { return rad / Math.PI / 2 * 360 };
        if (!Array.prototype.last) { Array.prototype.last = function () { return this[this.length - 1]; }; }; // enables [1,2,3].last()

        /*
        /////////////////// placeholder functions ///////////////////
        */

        // sample data generation
        var data = []

        let simpleSim = new FlexJointPID();
        simpleSim.plotFun = function (t, x, u, z, y, w) {

            data.push({ t: t, x: x, u: u, w: w, headAngle: rad2deg(y[0]), armAngle: rad2deg(y[1]), refAngle: rad2deg(w[0]) });

            // clip everything that is older than tmax
            data = data.filter((e) => { return e.t >= t - plotTime });
            updateFlexJointAngles(rad2deg(y[0]), rad2deg(y[1]), rad2deg(w[0]));
            updateOutGraph(data);
            updateinputGraph(data);
        };
        simpleSim.Kp = parseFloat($('#Kp').val());
        simpleSim.Ki = parseFloat($('#Ki').val());
        simpleSim.Kd = parseFloat($('#Kd').val());
        $('#Kp').on('change', function () { simpleSim.Kp = parseFloat(this.value); });
        $('#Ki').on('change', function () { simpleSim.Ki = parseFloat(this.value); });
        $('#Kd').on('change', function () { simpleSim.Kd = parseFloat(this.value); });
    </script>
</body>

</html>